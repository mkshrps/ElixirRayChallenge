defmodule Canvas do

  def build_canvas(width,height,init_color) do
    canvas = new_canvas_contig(width,height,init_color,0,{}) 
    %{canvas: canvas,width: width, height: height}
  end

  def new_canvas_contig(width,height,color,count,canvas) when count < (width * height) do
    new_canvas_contig(width,height,color,count+1,Tuple.append(canvas,color))  
  end

  def new_canvas_contig(_,_,_,_,canvas)  do
    canvas
  end
  
  def set_pixel_limit(canvas,width,height,row,col,color) when row <= height and col <= width do 
    #canvas = canvas_map[:canvas]
    #canvas = put_elem(canvas_map[:canvas],(canvas_map[:width] * (row-1))+(col-1),color) 
    canvas = put_elem(canvas, (width * (row-1))+col-1,color) 
    IO.inspect(canvas)
    #%{canvas_map | canvas: canvas}
  end

  def set_pixel_limit(_,_,_,_,_,_) do
    {:error , "x , y outside limits"}
  end

  def set_pixel(canvas_map,row,col,color) do
    canvas = put_elem(canvas_map[:canvas], (canvas_map[:width] * row)+col,color) 
    %{canvas_map | canvas: canvas}
#    IO.inspect(canvas)
  end

  def get_pixel(canvas_map,row,col) do
     elem(canvas_map[:canvas],canvas_map[:width] * (row) + (col))
  end

  def map_pixel(pixel_list) do
    Enum.map(pixel_list,fn t -> Tuple.to_list(t) end )
  end

  def get_row(list,start,count) do
   Enum.slice(list,start,count)
  end

  def generate_ppm_file(filename,r,c) do
    File.write(filename,"P3\n#{r} #{c}\n255\n")    
    #    make_row(r*c,0.1)
    |> canvas_to_ppm(0,r,c,filename)
  end

  @doc """
  canvas_to_ppm()
  Takes a canvas containing a number of rows of pixels
  Each row as a list of pixel tuples {r,g,b} each pixel value is a float between 0 and 1
  Each row is processed and output to a file defined by the filename 
  The file is assumed to contain the ppm header
  """
  def canvas_to_ppm(_canvas,_,_,0,_) do
    {:ok}   
  end

  def canvas_to_ppm(canvas,start,width,rowcount,fileptr) do
    get_row(canvas,start,width)
    |> line_to_string()
    #|> IO.inspect()
    |> add_to_file(fileptr)
    # output to file
    canvas_to_ppm(canvas,start + width,width,rowcount-1,fileptr)
  end

  def add_to_file(str,filename) do 
    File.write(filename,str,[:append])
  end

  def line_to_string(pixels) do
    # convert a canvas row (list of pixel tuples) to a flat list of values
    # mapped between 0 and 255
    Enum.reduce(pixels,[],fn {x,y,z}, acc -> [z,y,x|acc] end )
    |> Enum.map(fn 
       x when x <= 0 -> 0
       x when x >= 1 -> 255  
       x ->  trunc(x*255) 
      end)
    |> Enum.reverse()
    # output the flat list to a ppm string clipping lines at 70 chars max 
    |> to_str()
  end

  def to_str(list) do
    maxcount = 70
    to_str("",list,maxcount,0)
  end

  def to_str(str,[],_,_) do
    String.trim(str) <> "\n"
  end

  def to_str(str,list,maxcount,lcount) when lcount > maxcount do
    str = String.trim(str) <> "\n"
    to_str(str,list,maxcount,0)
  end

  # default operation add new value to the string 
  # this is the only place where we add a value to the string
  def to_str(str,[h|list],maxcount,lcount) do
    if (numlen(h) + lcount) > maxcount do
      # if next value won't fit on this line force a new line
      # lcount = maxcount + 1  
      to_str(str,[h|list],maxcount,maxcount+1)
      
    else
   #   lcount = lcount + String.length("#{h} ")
      str <> "#{h} "
      |> to_str(list,maxcount,lcount+ numlen(h) + space())
    end
  end
  def space(), do: 1 

  def numlen(n) do
    String.length("#{n}")
  end
  
  #
  # make_row() creates a canvas of pixels as a list for test 
  def  make_row(0,_) do
    []
  end

  def  make_row(width,n) do
    [{n,0,1}|make_row(width-1,n+0.1)]
  end
  #
  #

end
